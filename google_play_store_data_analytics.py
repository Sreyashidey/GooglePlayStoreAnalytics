# -*- coding: utf-8 -*-
"""Google_play_store_data_analytics.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xfNYilF36W5tyVNhW76zRLx9M1DQaig-
"""

import pandas as pd
import numpy as np
import plotly.express as px
import plotly.io as pio
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score
from nltk.sentiment.vader import SentimentIntensityAnalyzer
import nltk
import webbrowser
import os

nltk.download('vader_lexicon')

"""#Reading the data and cleaning process-"""

apps_df=pd.read_csv('Play Store Data.csv')
reviews_df=pd.read_csv('User Reviews.csv')

apps_df.head()

reviews_df.head()

apps_df = apps_df.dropna(subset=['Rating'])
for column in apps_df.columns :
    apps_df[column].fillna(apps_df[column].mode()[0],inplace=True)
apps_df.drop_duplicates(inplace=True)
apps_df=apps_df=apps_df[apps_df['Rating']<=5]
reviews_df.dropna(subset=['Translated_Review'],inplace=True)

apps_df.dtypes

apps_df['Installs']=apps_df['Installs'].str.replace(',','').str.replace('+','').astype(int)

apps_df['Price']=apps_df['Price'].str.replace('$','').astype(float)

apps_df.dtypes

merged_df=pd.merge(apps_df,reviews_df,on='App',how='inner')

merged_df.head()

def convert_size(size):
    if 'M' in size:
        return float(size.replace('M',''))
    elif 'k' in size:
        return float(size.replace('k',''))/1024
    else:
        return np.nan
apps_df['Size']=apps_df['Size'].apply(convert_size)

apps_df

apps_df['Log_Installs']=np.log(apps_df['Installs'])

apps_df['Reviews']=apps_df['Reviews'].astype(int)

apps_df['Log_Reviews']=np.log(apps_df['Reviews'])

apps_df.dtypes

def rating_group(rating):
    if rating >= 4:
        return 'Top rated app'
    elif rating >=3:
        return 'Above average'
    elif rating >=2:
        return 'Average'
    else:
        return 'Below Average'
apps_df['Rating_Group']=apps_df['Rating'].apply(rating_group)

apps_df['Revenue']=apps_df['Price']*apps_df['Installs']

sia = SentimentIntensityAnalyzer()

review = "This app is amazing! I love the new features."
sentiment_score= sia.polarity_scores(review)
print(sentiment_score)

review = "This app is very bad! I hate the new features."
sentiment_score= sia.polarity_scores(review)
print(sentiment_score)

review = "This app is okay."
sentiment_score= sia.polarity_scores(review)
print(sentiment_score)

reviews_df['Sentiment_Score']=reviews_df['Translated_Review'].apply(lambda x: sia.polarity_scores(str(x))['compound'])

reviews_df.head()

apps_df['Last Updated']=pd.to_datetime(apps_df['Last Updated'],errors='coerce')

apps_df['Year']=apps_df['Last Updated'].dt.year

apps_df.head()

html_files_path="./"
if not os.path.exists(html_files_path):
    os.makedirs(html_files_path)

plot_containers=""

def save_plot_as_html(fig, filename, insight):
    global plot_containers
    filepath = os.path.join(html_files_path, filename)
    html_content = pio.to_html(fig, full_html=False, include_plotlyjs='inline')
    plot_id = filename.split('.')[0]
    # Append the plot and its insight to plot_containers
    plot_containers += f"""
    <div class="plot-container" id="{plot_id}" onclick="openPlot('{filename}')">
        <div class="plot">{html_content}</div>
        <div class="insights">{insight}</div>
    </div>
    """
    fig.write_html(filepath, full_html=False, include_plotlyjs='inline')

plot_width=400
plot_height=300
plot_bg_color='black'
text_color='white'
title_font={'size':16}
axis_font={'size':12}

apps_df.columns

reviews_df.columns

"""Task 1- Create a scatter plot to visualize the relationship between revenue and the number of installs for paid apps only. Add a trendline to show the correlation and color-code the points based on app categories."""

import plotly.express as px
import os

paid_apps = apps_df[apps_df['Type'] == 'Paid']

fig1 = px.scatter(
    paid_apps,
    x="Installs",
    y="Revenue",
    color="Category",
    trendline="ols",
    labels={'Installs': 'Number of Installs', 'Revenue': 'Revenue ($)'},
    title="Revenue vs Installs for Paid Apps",
    width=400,
    height=300
)
fig1.update_traces(marker=dict(size=8, opacity=0.7))

fig1.update_layout(
    plot_bgcolor="black",
    paper_bgcolor="black",
    font_color="white",
    title_font={'size': 16},
    xaxis=dict(title_font={'size': 12}),
    yaxis=dict(title_font={'size': 12}),
    margin=dict(l=10, r=10, t=30, b=10)
)



save_plot_as_html(fig1, "plot1.html",
                  "This scatter plot shows the correlation between revenue and installs for paid apps on the Play Store, with categories color-coded.")

fig1.show()

"""

1.   There is a clear positive correlation between the number of installs and revenue generated. As the number of installs increases, the revenue also tends to increase.
2.   The Business category exhibits the highest revenue, suggesting that paid apps in this sector are particularly high.

"""

print(paid_apps[['Installs', 'Revenue', 'Category']].head())

"""Tak2- Use a grouped bar chart to compare the average rating and total review count for the top 10 app categories by number of installs. Filter out any categories where the average rating is below 4.0 and size below 10 M and last update should be Jan month . this graph should work only between 3PM IST to 5 PM IST apart from that time we should not show this graph in dashboard itself."""

import pandas as pd
import plotly.express as px
import datetime
import os

'''ist_now = datetime.datetime.utcnow() + datetime.timedelta(hours=5, minutes=30)
start_time = ist_now.replace(hour=15, minute=0, second=0, microsecond=0)
end_time = ist_now.replace(hour=17, minute=0, second=0, microsecond=0)  '''

#if start_time <= ist_now <= end_time:

filtered_apps = apps_df[
        (apps_df['Size'] >= 10) &
        (apps_df['Last Updated'].dt.month == 1)
    ]

category_stats = filtered_apps.groupby("Category").agg(
        avg_rating=("Rating", "mean"),
        total_reviews=("Reviews", "sum"),
        total_installs=("Installs", "sum")
    ).reset_index()

category_stats = category_stats[category_stats["avg_rating"] >= 4.0]


top_categories = category_stats.nlargest(10, "total_installs")


top_categories_melted = top_categories.melt(
        id_vars="Category",
        value_vars=["avg_rating", "total_reviews"],
        var_name="Metric",
        value_name="Value"
    )


fig2 = px.bar(
        top_categories_melted,
        x="Category",
        y="Value",
        color="Metric",
        barmode="group",
        labels={"Value": "Value", "Metric": "Metric"},
        title="Comparison of Average Rating and Total Reviews for Top 10 Categories",
        width=400,
        height=300
    )

fig2.update_layout(
        plot_bgcolor="black",
        paper_bgcolor="black",
        font_color="white",
        title_font={'size': 16},
        xaxis=dict(title_font={'size': 12}),
        yaxis=dict(title_font={'size': 12}),
        margin=dict(l=10, r=10, t=30, b=10)
    )

save_plot_as_html(fig2, "plot2.html",
                      "This grouped bar chart compares the average rating and total reviews for the top 10 app categories by installs, filtered for high-quality apps.")

fig2.show()

apps_df.head()

apps_df.columns
apps_df.info()

"""There is a clear disparity between average ratings and total reviews. Categories with higher reviews do not necessarily correlate to higher ratings, indicating that quantity does not always mean quality, especially in areas like Family and Game.

Task 3 -Generate a heatmap to show the correlation matrix between installs, ratings, and review counts. Filter the data to include only apps that have been updated within the last year and have at least 100,000 installs and reviews count should be more than 1k and genres name should not be Starting with characters A , F , E , G , I , K . this graph should work only between 2 PM IST to 4 PM IST apart from that time we should not show this graph in dashboard itself.
"""

import pandas as pd
import plotly.figure_factory as ff
import datetime
import re

'''ist_now = datetime.datetime.utcnow() + datetime.timedelta(hours=5, minutes=30)
start_time = ist_now.replace(hour=14, minute=0, second=0, microsecond=0)
end_time = ist_now.replace(hour=16, minute=0, second=0, microsecond=0)  '''

#if start_time <= ist_now <= end_time:

current_year = datetime.datetime.now().year

apps_df["Updated_Year"] = apps_df["Last Updated"].dt.year



filtered_apps = apps_df[
        (apps_df["Installs"] >= 100000) &
        (apps_df["Reviews"] > 1000) &
        (~apps_df["Genres"].str.startswith(('A', 'F', 'E', 'G', 'I', 'K'), na=False))
    ]


correlation_data = filtered_apps[["Installs", "Rating", "Reviews"]].corr()


fig3 = ff.create_annotated_heatmap(
        z=correlation_data.values,
        x=correlation_data.columns.tolist(),
        y=correlation_data.columns.tolist(),
        colorscale="Plasma",
        showscale=True,

    )

fig3.update_layout(
        title="Correlation Matrix: Installs, Ratings, and Reviews",
        width=400,
    height=300,
        plot_bgcolor="black",
        paper_bgcolor="white",
        font_color="white",
        title_font={'size': 16},
        margin=dict(l=10, r=10, t=30, b=10)
    )


save_plot_as_html(fig3, "plot3.html",
                      "This heatmap shows the correlation between installs, ratings, and reviews for filtered Play Store apps.")

filtered_apps.head()

apps1 = apps_df[

        (apps_df["Installs"] >= 100000) &
        (apps_df["Reviews"] > 1000) &
       (~apps_df["Genres"].str.startswith(('A', 'F', 'E', 'G', 'I', 'K'), na=False))
    ]

apps1.head()

"""No such dataframe exists with the required conditions"""

fig3.show()

"""#Training tasks"""

category_counts=apps_df['Category'].value_counts().nlargest(10)
fig4=px.bar(
    x=category_counts.index,
    y=category_counts.values,
    labels={'x':'Category','y':'Count'},
    title='Top Categories on Play Store',
    color=category_counts.index,
    color_discrete_sequence=px.colors.sequential.Plasma,
    width=400,
    height=300
)
fig4.update_layout(
    plot_bgcolor='black',
    paper_bgcolor='black',
    font_color='white',
    title_font={'size':16},
    xaxis=dict(title_font={'size':12}),
    yaxis=dict(title_font={'size':12}),
    margin=dict(l=10,r=10,t=30,b=10)
)
#fig1.update_traces(marker=dict(pattern=dict(line=dict(color='white',width=1))))
save_plot_as_html(fig4,"plot4.html","The top categories on the Play Store are dominated by tools, entertainment, and productivity apps")

fig4.show()

type_counts=apps_df['Type'].value_counts()
fig5=px.pie(
    values=type_counts.values,
    names=type_counts.index,
    title='App Type Distribution',
    color_discrete_sequence=px.colors.sequential.RdBu,
    width=400,
    height=300
)
fig5.update_layout(
    plot_bgcolor='black',
    paper_bgcolor='black',
    font_color='white',
    title_font={'size':16},
    margin=dict(l=10,r=10,t=30,b=10)
)

save_plot_as_html(fig5,"plot5.html","Most apps on the Playstore are free, indicating a strategy to attract users first and monetize through ads or in app purchases")

fig5.show()

fig6=px.histogram(
    apps_df,
    x='Rating',
    nbins=20,
    title='Rating Distribution',
    color_discrete_sequence=['#636EFA'],
    width=400,
    height=300
)
fig6.update_layout(
    plot_bgcolor='black',
    paper_bgcolor='black',
    font_color='white',
    title_font={'size':16},
    xaxis=dict(title_font={'size':12}),
    yaxis=dict(title_font={'size':12}),
    margin=dict(l=10,r=10,t=30,b=10)
)
#fig1.update_traces(marker=dict(pattern=dict(line=dict(color='white',width=1))))
save_plot_as_html(fig6,"plot6.html","Ratings are skewed towards higher values, suggesting that most apps are rated favorably by users")

fig6.show()

sentiment_counts=reviews_df['Sentiment_Score'].value_counts()
fig7=px.bar(
    x=sentiment_counts.index,
    y=sentiment_counts.values,
    labels={'x':'Sentiment Score','y':'Count'},
    title='Sentiment Distribution',
    color=sentiment_counts.index,
    color_discrete_sequence=px.colors.sequential.RdPu,
    width=400,
    height=300
)
fig7.update_layout(
    plot_bgcolor='black',
    paper_bgcolor='black',
    font_color='white',
    title_font={'size':16},
    xaxis=dict(title_font={'size':12}),
    yaxis=dict(title_font={'size':12}),
    margin=dict(l=10,r=10,t=30,b=10)
)
#fig1.update_traces(marker=dict(pattern=dict(line=dict(color='white',width=1))))
save_plot_as_html(fig7,"plot7.html","Sentiments in reviews show a mix of positive and negative feedback, with a slight lean towards positive sentiments")

fig7.show()

installs_by_category=apps_df.groupby('Category')['Installs'].sum().nlargest(10)
fig8=px.bar(
    x=installs_by_category.index,
    y=installs_by_category.values,
    orientation='h',
    labels={'x':'Installs','y':'Category'},
    title='Installs by Category',
    color=installs_by_category.index,
    color_discrete_sequence=px.colors.sequential.Blues,
    width=400,
    height=300
)
fig8.update_layout(
    plot_bgcolor='black',
    paper_bgcolor='black',
    font_color='white',
    title_font={'size':16},
    xaxis=dict(title_font={'size':12}),
    yaxis=dict(title_font={'size':12}),
    margin=dict(l=10,r=10,t=30,b=10)
)

save_plot_as_html(fig8,"plot8.html","The categories with the most installs are social and communication apps, reflecting their broad appeal and daily usage")

fig8.show()

# Updates Per Year Plot
updates_per_year = apps_df['Last Updated'].dt.year.value_counts().sort_index()
fig9 = px.line(
    x=updates_per_year.index,
    y=updates_per_year.values,
    labels={'x': 'Year', 'y': 'Number of Updates'},
    title='Number of Updates Over the Years',
    color_discrete_sequence=['#AB63FA'],
    width=plot_width,
    height=plot_height
)
fig9.update_layout(
    plot_bgcolor=plot_bg_color,
    paper_bgcolor=plot_bg_color,
    font_color=text_color,
    title_font=title_font,
    xaxis=dict(title_font=axis_font),
    yaxis=dict(title_font=axis_font),
    margin=dict(l=10, r=10, t=30, b=10)
)
save_plot_as_html(fig9, "plot9.html", "Updates have been increasing over the years, showing that developers are actively maintaining and improving their apps.")

fig9.show()

revenue_by_category=apps_df.groupby('Category')['Revenue'].sum().nlargest(10)
fig10=px.bar(
    x=installs_by_category.index,
    y=installs_by_category.values,
    labels={'x':'Category','y':'Revenue'},
    title='Revenue by Category',
    color=installs_by_category.index,
    color_discrete_sequence=px.colors.sequential.Greens,
    width=400,
    height=300
)
fig10.update_layout(
    plot_bgcolor='black',
    paper_bgcolor='black',
    font_color='white',
    title_font={'size':16},
    xaxis=dict(title_font={'size':12}),
    yaxis=dict(title_font={'size':12}),
    margin=dict(l=10,r=10,t=30,b=10)
)

save_plot_as_html(fig10,"plot10.html","Categories such as Business and Productivity lead in revenue generation, indicating their monetization potential")

fig10.show()

genre_counts=apps_df['Genres'].str.split(';',expand=True).stack().value_counts().nlargest(10)
fig11=px.bar(
    x=genre_counts.index,
    y=genre_counts.values,
    labels={'x':'Genre','y':'Count'},
    title='Top Genres',
    color=installs_by_category.index,
    color_discrete_sequence=px.colors.sequential.OrRd,
    width=400,
    height=300
)
fig11.update_layout(
    plot_bgcolor='black',
    paper_bgcolor='black',
    font_color='white',
    title_font={'size':16},
    xaxis=dict(title_font={'size':12}),
    yaxis=dict(title_font={'size':12}),
    margin=dict(l=10,r=10,t=30,b=10)
)
#fig1.update_traces(marker=dict(pattern=dict(line=dict(color='white',width=1))))
save_plot_as_html(fig11,"plot11.html","Action and Casual genres are the most common, reflecting users' preference for engaging and easy-to-play games")

fig11.show()

fig12=px.scatter(
    apps_df,
    x='Last Updated',
    y='Rating',
    color='Type',
    title='Impact of Last Update on Rating',
    color_discrete_sequence=px.colors.qualitative.Vivid,
    width=400,
    height=300
)
fig12.update_layout(
    plot_bgcolor='black',
    paper_bgcolor='black',
    font_color='white',
    title_font={'size':16},
    xaxis=dict(title_font={'size':12}),
    yaxis=dict(title_font={'size':12}),
    margin=dict(l=10,r=10,t=30,b=10)
)

save_plot_as_html(fig12,"plot12.html","The Scatter Plot shows a weak correlation between the last update and ratings, suggesting that more frequent updates dont always result in better ratings.")

fig12.show()

fig13=px.box(
    apps_df,
    x='Type',
    y='Rating',
    color='Type',
    title='Rating for Paid vs Free Apps',
    color_discrete_sequence=px.colors.qualitative.Pastel,
    width=400,
    height=300
)
fig13.update_layout(
    plot_bgcolor='black',
    paper_bgcolor='black',
    font_color='white',
    title_font={'size':16},
    xaxis=dict(title_font={'size':12}),
    yaxis=dict(title_font={'size':12}),
    margin=dict(l=10,r=10,t=30,b=10)
)

save_plot_as_html(fig13,"plot13.html","Paid apps generally have higher ratings compared to free apps, suggesting that users expect higher quality from apps they pay for")

fig13.show()

plot_containers_split=plot_containers.split('</div>')

if len(plot_containers_split) > 1:
    final_plot=plot_containers_split[-2]+'</div>'
else:
    final_plot=plot_containers

dashboard_html= """
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name=viewport" content="width=device-width,initial-scale-1.0">
    <title> Google Play Store Review Analytics</title>
    <style>
        body {{
            font-family: Arial, sans-serif;
            background-color: #333;
            color: #fff;
            margin: 0;
            padding: 0;
        }}
        .header {{
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            background-color: #444
        }}
        .header img {{
            margin: 0 10px;
            height: 50px;
        }}
        .container {{
            display: flex;
            flex-wrap: wrap;
            justify_content: center;
            padding: 20px;
        }}
        .plot-container {{
            border: 2px solid #555
            margin: 10px;
            padding: 10px;
            width: {plot_width}px;
            height: {plot_height}px;
            overflow: hidden;
            position: relative;
            cursor: pointer;
        }}
        .insights {{
            display: none;
            position: absolute;
            right: 10px;
            top: 10px;
            background-color: rgba(0,0,0,0.7);
            padding: 5px;
            border-radius: 5px;
            color: #fff;
        }}
        .plot-container: hover .insights {{
            display: block;
        }}
        </style>
        <script>
            function openPlot(filename) {{
                window.open(filename, '_blank');
                }}

                 function updatePlotVisibility() {{
            let now = new Date();
            let hours = now.getHours();

            let plot2 = document.getElementById("plot2");
            let plot3 = document.getElementById("plot3");

            if (plot2) {{
                plot2.style.display = (hours >= 15 && hours < 17) ? "block" : "none";
            }}

            if (plot3) {{
                plot3.style.display = (hours >= 14 && hours < 16) ? "block" : "none";
            }}
        }}

        // Update plot visibility every minute
        setInterval(updatePlotVisibility, 60000);
        updatePlotVisibility();
        </script>
    </head>
    <body>
        <div class= "header">
            <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/4a/Logo_2013_Google.png/800px-Logo_2013_Google.png" alt="Google Logo">
            <h1>Google Play Store Reviews Analytics</h1>
            <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/78/Google_Play_Store_badge_EN.svg/1024px-Google_Play_Store_badge_EN.svg.png" alt="Google Play Store Logo">
        </div>
        <div class="container">
            {plots}
        </div>
    </body>
    </html>
    """

final_html=dashboard_html.format(plots=plot_containers,plot_width=plot_width,plot_height=plot_height)

dashboard_path=os.path.join(html_files_path,"index.html")

with open(dashboard_path, "w", encoding="utf-8") as f:
    f.write(final_html)

import os

print(os.path.realpath(dashboard_path))